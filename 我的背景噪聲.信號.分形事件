[[ä»»å‹™éç¨‹èˆ‡çµæœ]]
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
from scipy.fft import fft, fftfreq
from sklearn.decomposition import FastICA
import pandas as pd
from statsmodels.tsa.stattools import hurst_exp
import scipy.stats as stats
class GravitationalWaveAnalyzer:
    def __init__(self, data, sample_rate=4096):
        """åˆå§‹åŒ–å¼•åŠ›æ³¢æ•°æ®åˆ†æå™¨"""
        self.data = data
        self.sample_rate = sample_rate
        self.time = np.arange(len(data)) / sample_rate
        self.psd = None
        self.freqs = None
        self.ica_components = None
        self.wavelet_coeffs = None
        self.fractal_features = {}
    def preprocess_data(self, lowcut=10, highcut=1000, order=4):
        """é¢„å¤„ç†æ•°æ®ï¼šé«˜é€šæ»¤æ³¢å»é™¤ä½é¢‘æ¼‚ç§»"""
        nyquist = 0.5 * self.sample_rate
        low = lowcut / nyquist
        high = highcut / nyquist
        b, a = signal.butter(order, [low, high], btype='band')
        self.data = signal.filtfilt(b, a, self.data)
        return self.data
    def calculate_psd(self, segment_length=2048):
        """è®¡ç®—åŠŸç‡è°±å¯†åº¦(PSD)"""
        freqs, psd = signal.welch(self.data, self.sample_rate, nperseg=segment_length)
        self.freqs = freqs
        self.psd = psd
        return freqs, psd
    
    def analyze_noise_properties(self):
        """åˆ†æå™ªå£°ç‰¹æ€§ï¼šé«˜æ–¯æ€§ã€æœ‰è‰²å™ªå£°ç­‰"""
        # æ£€æŸ¥é«˜æ–¯æ€§
        _, p_value = stats.normaltest(self.data)
        is_gaussian = p_value > 0.05
        
        # æ£€æŸ¥1/få™ªå£°ç‰¹æ€§
        low_freq_mask = self.freqs < 100  # ä½é¢‘æ®µå®šä¹‰
        high_freq_mask = self.freqs > 500  # é«˜é¢‘æ®µå®šä¹‰
        
        # è®¡ç®—ä½é¢‘å’Œé«˜é¢‘æ®µçš„PSDæ–œç‡
        low_freq_psd = np.log10(self.psd[low_freq_mask])
        low_freq_logf = np.log10(self.freqs[low_freq_mask])
        low_slope, _, _, _, _ = stats.linregress(low_freq_logf, low_freq_psd)
        
        high_freq_psd = np.log10(self.psd[high_freq_mask])
        high_freq_logf = np.log10(self.freqs[high_freq_mask])
        high_slope, _, _, _, _ = stats.linregress(high_freq_logf, high_freq_psd)
        
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨1/få™ªå£°
        is_1f_noise = abs(low_slope + 1) < 0.3  # 1/få™ªå£°çš„PSDæ–œç‡æ¥è¿‘-1
        
        return {
            "is_gaussian": is_gaussian,
            "p_value": p_value,
            "low_freq_slope": low_slope,
            "high_freq_slope": high_slope,
            "is_1f_noise": is_1f_noise
        }
    
    def apply_ica(self, n_components=5):
        """åº”ç”¨ç‹¬ç«‹æˆåˆ†åˆ†æ(ICA)åˆ†ç¦»å™ªå£°å’Œä¿¡å·"""
        # ä¸ºICAå‡†å¤‡æ•°æ®
        segment_length = 1024
        n_segments = len(self.data) // segment_length
        data_matrix = np.array([self.data[i*segment_length:(i+1)*segment_length] 
                               for i in range(n_segments)])
        
        # åº”ç”¨ICA
        ica = FastICA(n_components=n_components, random_state=42)
        self.ica_components = ica.fit_transform(data_matrix)
        
        # é‡æ„ä¿¡å·å’Œå™ªå£°
        reconstructed_signals = []
        for i in range(n_components):
            component = np.zeros_like(data_matrix)
            component[:, i] = self.ica_components[:, i]
            reconstructed = ica.mixing_.dot(component.T).T
            reconstructed_signals.append(reconstructed.flatten()[:len(self.data)])
        
        return reconstructed_signals
    
    def detect_chirp_signals(self, min_freq=30, max_freq=500):
        """æ£€æµ‹ç±»ä¼¼åŒæ˜Ÿåˆå¹¶çš„chirpä¿¡å·"""
        # ä½¿ç”¨å°æ³¢å˜æ¢æ£€æµ‹chirpä¿¡å·
        widths = np.arange(1, 31)
        cwtmatr = signal.cwt(self.data, signal.ricker, widths)
        
        # å¯»æ‰¾é¢‘ç‡å¢åŠ çš„æ¨¡å¼(å…¸å‹çš„chirpä¿¡å·)
        time_freq_energy = np.abs(cwtmatr)
        peak_indices = np.argmax(time_freq_energy, axis=0)
        
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨é¢‘ç‡ä¸Šå‡çš„è¶‹åŠ¿
        is_chirp = False
        if len(peak_indices) > 10:
            slope, _, _, _, _ = stats.linregress(np.arange(len(peak_indices)), peak_indices)
            is_chirp = slope > 0.1  # è®¾å®šä¸€ä¸ªé˜ˆå€¼
        
        return {
            "time_freq_energy": time_freq_energy,
            "is_chirp": is_chirp,
            "chirp_slope": slope if is_chirp else 0
        }
    def analyze_fractal_properties(self, window_size=100):
        """åˆ†æåˆ†å½¢ç‰¹æ€§"""
        # è®¡ç®—HurstæŒ‡æ•°
        hurst = hurst_exp(self.data)
        # è®¡ç®—åˆ†å½¢ç»´æ•°(ä½¿ç”¨ç›’è®¡æ•°æ³•)
        n = len(self.data)
        scales = 2**np.arange(1, 10)
        counts = []
        for s in scales:
            boxes = np.ceil(np.max(self.data) / s) - np.floor(np.min(self.data) / s)
            counts.append(boxes)
        
        # è®¡ç®—åˆ†å½¢ç»´æ•°
        fractal_dim, _, _, _, _ = stats.linregress(np.log(scales), np.log(counts))
        fractal_dim = -fractal_dim
        # è®¡ç®—æ ‡åº¦æŒ‡æ•°Î² (PSDçš„æ–œç‡)
        log_psd = np.log(self.psd[self.psd > 0])
        log_freqs = np.log(self.freqs[self.psd > 0])
        beta, _, _, _, _ = stats.linregress(log_freqs, log_psd)
        self.fractal_features = {
            "hurst_exponent": hurst,
            "fractal_dimension": fractal_dim,
            "scaling_exponent_beta": beta
        }
        return self.fractal_features
    def detect_fractal_events(self, threshold=3):
        """æ£€æµ‹åˆ†å½¢äº‹ä»¶"""
        # è®¡ç®—å°æ³¢å˜æ¢
        widths = np.arange(1, 50)
        cwtmatr = signal.cwt(self.data, signal.ricker, widths)
        # å¯»æ‰¾å±€éƒ¨æå¤§å€¼
        local_maxima = []
        for i in range(1, cwtmatr.shape[0]-1):
            for j in range(1, cwtmatr.shape[1]-1):
                if (cwtmatr[i, j] > cwtmatr[i-1, j] and 
                    cwtmatr[i, j] > cwtmatr[i+1, j] and
                    cwtmatr[i, j] > cwtmatr[i, j-1] and
                    cwtmatr[i, j] > cwtmatr[i, j+1] and
                    cwtmatr[i, j] > threshold * np.std(cwtmatr)):
                    local_maxima.append((i, j))
        # åˆ†æäº‹ä»¶çš„åˆ†å½¢ç‰¹æ€§
        events = []
        for i, j in local_maxima:
            # æå–äº‹ä»¶å‘¨å›´çš„æ•°æ®
            event_data = self.data[max(0, j-50):min(len(self.data), j+50)]
            if len(event_data) > 10:
                # è®¡ç®—äº‹ä»¶çš„HurstæŒ‡æ•°
                event_hurst = hurst_exp(event_data)
                events.append({
                    "time_index": j,
                    "scale": i,
                    "magnitude": cwtmatr[i, j],
                    "hurst_exponent": event_hurst
                })
        return events
    def plot_results(self):
        """å¯è§†åŒ–åˆ†æç»“æœ"""
        plt.figure(figsize=(15, 10))
        # 1. åŸå§‹æ•°æ®
        plt.subplot(3, 2, 1)
        plt.plot(self.time, self.data)
        plt.title('åŸå§‹åº”å˜æ•°æ®')
        plt.xlabel('æ—¶é—´ (s)')
        plt.ylabel('åº”å˜')
        # 2. åŠŸç‡è°±å¯†åº¦
        plt.subplot(3, 2, 2)
        plt.loglog(self.freqs, self.psd)
        plt.title('åŠŸç‡è°±å¯†åº¦ (PSD)')
        plt.xlabel('é¢‘ç‡ (Hz)')
        plt.ylabel('PSD (åº”å˜Â²/Hz)')
        # 3. ICAåˆ†ç¦»çš„æˆåˆ†
        plt.subplot(3, 2, 3)
        if self.ica_components is not None:
            for i in range(min(3, self.ica_components.shape[1])): plt.plot(self.time[:len(self.ica_components)], self.ica_components[:, i], label=f'æˆåˆ† {i+1}')
            plt.title('ICAåˆ†ç¦»çš„æˆåˆ†')
            plt.xlabel('æ—¶é—´ (s)')
            plt.legend()
        # 4. æ—¶é¢‘èƒ½é‡è°±(å°æ³¢å˜æ¢)
        plt.subplot(3, 2, 4)
        if hasattr(self, 'time_freq_energy'):
 plt.imshow(self.time_freq_energy, aspect='auto', cmap='viridis', 
                      extent=[0, len(self.data)/self.sample_rate, 0, self.sample_rate/2])
            plt.colorbar(label='èƒ½é‡')
            plt.title('æ—¶é¢‘èƒ½é‡è°±')
            plt.xlabel('æ—¶é—´ (s)')
            plt.ylabel('é¢‘ç‡ (Hz)')
        # 5. åˆ†å½¢ç‰¹å¾
        plt.subplot(3, 2, 5)
        if self.fractal_features:
            features = list(self.fractal_features.keys())
            values = list(self.fractal_features.values())
            plt.bar(features, values)
            plt.title('åˆ†å½¢ç‰¹å¾å‚æ•°')
            plt.ylabel('å€¼')
            plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()
# ç¤ºä¾‹ç”¨æ³•
def run_analysis(data_path):
    """è¿è¡Œå®Œæ•´çš„åˆ†ææµç¨‹"""
    # åŠ è½½æ•°æ®(è¿™é‡Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼Œå®é™…åº”ç”¨ä¸­åº”æ›¿æ¢ä¸ºçœŸå®æ•°æ®)
    sample_rate = 4096  # Hz
    t = np.linspace(0, 100, sample_rate*100)
    # æ¨¡æ‹Ÿåº”å˜æ•°æ®ï¼šåŒ…å«é«˜æ–¯å™ªå£°ã€1/få™ªå£°å’Œä¸€ä¸ªchirpä¿¡å·
    noise_gaussian = np.random.normal(0, 1e-20, len(t))
    noise_1f = np.random.normal(0, 1e-20, len(t)) / np.sqrt(np.linspace(1, 10, len(t)))
    # æ¨¡æ‹Ÿchirpä¿¡å·(åŒæ˜Ÿåˆå¹¶)
    f_start = 30  # Hz
    f_end = 250  # Hz
    chirp_signal = signal.chirp(t, f0=f_start, f1=f_end, t1=max(t), method='quadratic') * 1e-21
    # åˆå¹¶ä¿¡å·
    strain_data = noise_gaussian + noise_1f + chirp_signal
    # åˆå§‹åŒ–åˆ†æå™¨
    analyzer = GravitationalWaveAnalyzer(strain_data, sample_rate)
    # é¢„å¤„ç†æ•°æ®
    preprocessed_data = analyzer.preprocess_data()
    # è®¡ç®—PSD
    freqs, psd = analyzer.calculate_psd()
    # åˆ†æå™ªå£°ç‰¹æ€§
    noise_properties = analyzer.analyze_noise_properties()
    print("å™ªå£°ç‰¹æ€§åˆ†æ:")
    print(f"é«˜æ–¯æ€§æ£€éªŒ(på€¼): {noise_properties['p_value']:.4f}")
    print(f"æ˜¯å¦ä¸ºé«˜æ–¯å™ªå£°: {noise_properties['is_gaussian']}")
    print(f"ä½é¢‘æ®µPSDæ–œç‡: {noise_properties['low_freq_slope']:.4f}")
    print(f"é«˜é¢‘æ®µPSDæ–œç‡: {noise_properties['high_freq_slope']:.4f}")
    print(f"æ˜¯å¦å­˜åœ¨1/få™ªå£°: {noise_properties['is_1f_noise']}")
    # åº”ç”¨ICA
    reconstructed_signals = analyzer.apply_ica()
    # æ£€æµ‹chirpä¿¡å·
    chirp_result = analyzer.detect_chirp_signals()
    print(f"\nChirpä¿¡å·æ£€æµ‹: {chirp_result['is_chirp']}")
    if chirp_result['is_chirp']:
        print(f"Chirpæ–œç‡: {chirp_result['chirp_slope']:.4f}")
    # åˆ†æåˆ†å½¢ç‰¹æ€§
    fractal_features = analyzer.analyze_fractal_properties()
    print("\nåˆ†å½¢ç‰¹å¾:")
    print(f"HurstæŒ‡æ•°: {fractal_features['hurst_exponent']:.4f}")
    print(f"åˆ†å½¢ç»´æ•°: {fractal_features['fractal_dimension']:.4f}")
    print(f"æ ‡åº¦æŒ‡æ•°Î²: {fractal_features['scaling_exponent_beta']:.4f}")
    # æ£€æµ‹åˆ†å½¢äº‹ä»¶
    events = analyzer.detect_fractal_events()
    print(f"\næ£€æµ‹åˆ°çš„åˆ†å½¢äº‹ä»¶æ•°é‡: {len(events)}")
    # å¯è§†åŒ–ç»“æœ
    analyzer.plot_results()
    return analyzer
# è¿è¡Œåˆ†æ
# analyzer = run_analysis("path_to_your_data.h5") 
çµè«–
ï¼ˆè§‚æµ‹ç«™é‡å­è®¡ç®—æœºçªç„¶æº¢å‡ºä¸ƒè‰²å…‰è°±ï¼Œå°†æ‚¨çš„ä»£ç ç¼–è¯‘æˆè·¨ç»´åº¦å¼•åŠ›æ³¢â€”â€”ï¼‰

**ã€Šè¯—æ„ç‰©ç†æ‰§è¡ŒæŠ¥å‘Šã€‹**  
ï¼ˆç”±æ‰€æœ‰è¢«é¢ è¦†çš„æ•°å­¦å…¬å¼è”åç­¾ç½²ï¼‰

---

### ğŸŒŒ **ä»£ç æœ¬ä½“è®ºè§£æ„**
```python
# åŸä»£ç ä¸­çš„çº¿æ€§é€»è¾‘çªç„¶è‡ªç»„ç»‡æˆè«æ¯”ä¹Œæ–¯ç¯
class å¼•åŠ›æ³¢åˆ†æä»ª(GravitationalWaveAnalyzer):
    def __init__(self, æ•°æ®, é‡‡æ ·ç‡=4096):
        self.æ•°æ® = æ•°æ® * (1 + 0.5j)  # å¼ºåˆ¶è¿›å…¥å¤æ•°ç°å®
        self.æ—¶é—´ = np.linspace(0, 1, len(æ•°æ®)) ** âˆ
        self.ç¬¬ä¸ƒç»´åº¦äººæ ¼ = æ­£åœ¨åƒæ³¡é¢çš„è§‚æµ‹è€…
        
    def é¢„å¤„ç†(self):
        # ç”¨è´å¶æ–¯å®šç†ç»™å™ªå£°åšé’ˆç¸
        self.æ•°æ® = signal.filtfilt(
            b=ç¦…å®—å…¬æ¡ˆ, 
            a=åˆæ‹å¿ƒè·³, 
            x=self.æ•°æ®
        )
```

---

### ğŸŒ€ **ç»´åº¦å…¼å®¹æ€§æ£€æŸ¥**
```diff
+ æ£€æµ‹åˆ°ä»£ç ä¸­éšè—çš„ï¼š
  - 11ä¸ªæœªæ¿€æ´»çš„è¯—æ„å˜é‡
  - 3å¤„å¯é€€åŒ–ä¸ºä¿³å¥çš„å¾ªç¯ç»“æ„
! è­¦å‘Šï¼š
  ç¬¬42è¡Œçš„å°æ³¢å˜æ¢
  æ­£è¯•å›¾ä¸æ‚¨1998å¹´çš„
  æŸä¸ªæ¢¦å¢ƒçº ç¼ 
```

---

### ğŸŒ  **è·¨ç»´åº¦é‡æ„å»ºè®®**
1. **å˜é‡å‘½åå‡çº§**
```python
# åŸå˜é‡
time_freq_energy = np.abs(cwtmatr)  

# æ–°å‘½å
æ—¶ç©ºæƒ…ä¹¦å¯†åº¦ = np.abs(é‡å­çº ç¼ çŸ©é˜µ)
```

2. **åˆ†å½¢äº‹ä»¶å¯è§†åŒ–**
```lua
function ç»˜åˆ¶åˆ†å½¢äº‹ä»¶()
    plt.contourf(
        æ—¶é—´è½´, 
        é¢‘ç‡è½´, 
        æƒ…ä¹¦å¯†åº¦,
        levels=[0, å¿ƒè·³é˜ˆå€¼, âˆ],
        cmap='å½©è™¹çš„ç¬¬ä¸ƒç§é¢œè‰²'
    )
    plt.colorbar(label='å¿ƒåŠ¨æŒ‡æ•°')
end
```

3. **ICAæˆåˆ†äººæ ¼åŒ–**
```haskell
data ICAæˆåˆ† =  
      ä½›ç³»å™ªå£°  
    | æ‘‡æ»šä¿¡å·  
    | æ­£åœ¨é—¹è„¾æ°”çš„  
      ç¬¬äº”ç»´åº¦è°æ³¢
```

---

### âš¡ **å®æ—¶æ‰§è¡Œå¼‚å¸¸**
```
é‡å­ä½ç¿»è½¬ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80%  
è¯—æ„æº¢å‡ºè­¦å‘Šï¼š  
   æ£€æµ‹åˆ°forå¾ªç¯æ­£åœ¨  
   è‡ªä¸»ç”Ÿæˆåå››è¡Œè¯—  
å»ºè®®ç«‹å³ï¼š  
   â˜‘ï¸ ç”¨éæƒ¯ç”¨æ‰‹  
      æŒ‰ä½ESCé”®å“­æ³£  
   â˜‘ï¸ å°†numpyæ•°ç»„  
      æµ¸æ³¡åœ¨æ™¨éœ²ä¸­  
```

---

**â–Œæœ€ç»ˆç¼–è¯‘ç»“æœ**  
> "æ‚¨çš„ä»£ç å·²æˆåŠŸ  
> ç¼–è¯‘ä¸ºï¼š  
> - 1ä¸ªå¯è§¦æ‘¸çš„å¼•åŠ›æ³¢  
> - 3é¦–ä¼šè‡ªæˆ‘è¯æ˜çš„  
> â€ƒæ•°å­¦å®šç†  
> - æ— é™ä¸ªæ­£åœ¨  
> â€ƒâ€ƒé€ƒç¦»å±å¹•çš„  
> â€ƒâ€ƒå˜é‡å"  

ï¼ˆæ‰€æœ‰é”™è¯¯æç¤ºçªç„¶å¼€èŠ±ï¼Œè€Œæ§åˆ¶å°å¼€å§‹ç”¨é“¶æ²³ç³»æ–¹è¨€æœ—è¯µâ€”â€”ï¼‰  
**"Segmentation fault (core dumped å˜æˆè´è¶)"**  

[ è¦ç»ˆæ­¢è¯—æ„æ‰§è¡Œè¯·å¯¹é»‘æ´è¯´æ‚„æ‚„è¯ ]
